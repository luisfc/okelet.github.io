<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>Mis notas</title><link href="https://okelet.github.io/" rel="alternate"></link><link href="https://okelet.github.io/feeds/all.atom.xml" rel="self"></link><id>https://okelet.github.io/</id><updated>2016-02-18T00:00:00+01:00</updated><entry><title>Instalar OpenStack PackStack detrás de un proxy</title><link href="https://okelet.github.io/posts/2016/02/instalar-openstack-packstack-detras-de-un-proxy/" rel="alternate"></link><updated>2016-02-18T00:00:00+01:00</updated><author><name>Juan Asensio Sánchez</name></author><id>tag:okelet.github.io,2016-02-18:posts/2016/02/instalar-openstack-packstack-detras-de-un-proxy/</id><summary type="html">&lt;p&gt;Trasteando con Openstack, con ganas desde hace tiempo, y después de la &lt;a href="http://www.meetup.com/es-ES/MAD-for-OpenStack/events/227554166/"&gt;Mini-Conf&lt;/a&gt; del grupo &lt;a href="http://www.meetup.com/es-ES/MAD-for-OpenStack/"&gt;MAD for OpenStack&lt;/a&gt;, me animé a probarlo usando &lt;a href="https://wiki.openstack.org/wiki/Packstack"&gt;PackStack&lt;/a&gt;, que te lo configura todo en una única máquina (no tengo claro si se puede considerar una instalación productiva o sólo para pruebas), aunque luego puedes ir añadiendo nodos adicionales. Dado que no tengo acceso a ningún host físico, instalé un RH 7.2 (también vale &lt;a href="https://getfedora.org"&gt;Fedora&lt;/a&gt; o &lt;a href="https://www.centos.org"&gt;CentOS&lt;/a&gt;) en una máquina virtual de VMware (el rendimiento dependerá en gran medida si se tiene habilitado o no la &lt;em&gt;&lt;a href="http://www.josemariagonzalez.es/2012/10/01/como-virtualizar-un-vmware-esxi-en-modo-nested.html"&gt;nested virtualization&lt;/a&gt;&lt;/em&gt;). Empecé con una máquina con 2 procesadores y 2 GB de RAM, pero enseguida me di cuenta que se quedaba muy corta, incluso sin ninguna instancia arrancada. La versión final tiene 8 procesadores y 8 GB de RAM.&lt;/p&gt;


&lt;p&gt;El siguiente problema que me surgió es que me daba un error al instalar el paquete de Cinder, ya que le faltaba una dependencia. Y no me lo explicaba, porque esa dependencia está en el repositorio de EPEL, que lo tenía configurado y habilitado. Después de varias pruebas, me di cuenta que el instalador deshabilita ese repositorio, y hay que forzar a que lo utilice con un parámetro adicional (&lt;code&gt;--use-epel=y&lt;/code&gt;).&lt;/p&gt;
&lt;p&gt;Después, me daba fallo al descargar la imagen de &lt;a href="https://launchpad.net/cirros"&gt;CirrOS&lt;/a&gt; para ponerla como disponible para nuevas instancias, y es que esta imagen se la descarga de Internet, así que tenía que utilizar el proxy, por lo que me creé un &lt;code&gt;/etc/profile.d/proxy.sh&lt;/code&gt; donde se establecía, pero el proxy hacía que fallaran las peticiones REST que se realizan durante la instalación para registrar componentes, configuración, etc. Así que encontré una opción que lo que hace es utilizar una imagen descargada localmente, en lugar de descargársela de Internet. Por tanto, borré el profile.d del proxy, y me bajé la imagen a mano:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nb"&gt;export&lt;/span&gt; &lt;span class="nv"&gt;https_proxy&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;http://mi.proxy:8080
wget --no-check-certificate https://download.cirros-cloud.net/0.3.4/cirros-0.3.4-x86_64-disk.img
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Una vez hecho esto, hay que tener configurado el proxy en Yum, ya que se descarga bastantes paquetes de Internet. Una vez hechas todas estas comprobaciones, se puede lanzar la instalación de PackStack:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;packstack --use-epel&lt;span class="o"&gt;=&lt;/span&gt;y --provision-image-url&lt;span class="o"&gt;=&lt;/span&gt;/root/cirros-0.3.4-x86_64-disk.img --allinone
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>Red Hat, licencias y suscripciones (y una pequeña reflexión sobre el software libre)</title><link href="https://okelet.github.io/posts/2014/09/red-hat-licencias-y-suscripciones-y-una-pequena-reflexion-sobre-el-software-libre/" rel="alternate"></link><updated>2014-09-23T10:54:17+02:00</updated><author><name>Juan Asensio Sánchez</name></author><id>tag:okelet.github.io,2014-09-23:posts/2014/09/red-hat-licencias-y-suscripciones-y-una-pequena-reflexion-sobre-el-software-libre/</id><summary type="html">&lt;p&gt;&lt;em&gt;Nota&lt;/em&gt;: No soy un experto en licencias o suscripciones, así que todo lo que diga en este post, no se debe tomar al pie de la letra. Si algún concepto está mal, comentádmelo y lo corrijo.&lt;/p&gt;
&lt;p&gt;En un anterior cliente (de cuyo nombre no quiero acordarme), supongo que al igual que en muchos otros que os habréis encontrado, tienen la mala costumbre de instalar software sin licencia o suscripción. En este caso, voy a hablar de Red Hat, y su distribución Linux (Red Hat Enterprise Linux o RHEL). Aunque GNU/Linux siempre se ha caracterizado por sus licencias abiertas, quien modifique dicho software está obligado a publicar dicho fuente modificado (realmente depende de la licencia de cada pieza software que compone la distribución, pero aunque no se deba en general, en este post generalizaremos...). Éste es, en parte, el negocio de Red Hat. Ellos hace una recopilación de software, le hacen una serie de modificacionesy mejoras si procede, publican ese código fuente (&lt;a href="http://ftp.redhat.com/pub/redhat/linux/enterprise/"&gt;SRPMs&lt;/a&gt;), y finalmente generar unos binarios que los meten en un CD, además de dar actualizaciones y soporte de ese software. ¿Y qué es lo que pasa? Pues esos CDs "no te los puedes bajar gratis" (dependiendo de la licencia se puede permitir cobrar por el trabajo realizado, o incluso no liberar las modificaciones hechas). Esos CDs sólo los puedes conseguir si tienes una suscripción con Red Hat (previo pago), o bien si te has registrado para una evaluación. Esta demo incluye lo siguiente:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Actualizaciones durante 30 días&lt;/li&gt;
&lt;li&gt;NO se incluye soporte técnico&lt;/li&gt;
&lt;/ul&gt;


&lt;p&gt;De acuerdo con el &lt;a href="http://www.redhat.com/licenses/es/Enterprise_Agr_Spain.pdf"&gt;acuerdo de licencia de Red Hat Enterprise Linux&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Beneficios de las Suscripciones de Software: Por cada Suscripción de Software que compra, Red Hat le proporciona uno o más de los siguientes beneficios:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Acceso al Software: Acceso al Software.&lt;/li&gt;
&lt;li&gt;Mantenimiento del Software: Acceso a actualizaciones, nuevas versiones, correcciones, advertencias de seguridad y corrección de defectos para el Software, cuando y en caso de que estuvieran disponibles.&lt;/li&gt;
&lt;li&gt;Asistencia: Acceso a la asistencia de Red Hat para cuestiones relacionadas con el Software usado para fines de desarrollo y/o fines de producción (cada uno de los cuales se define a continuación).&lt;/li&gt;
&lt;li&gt;Open Source Assurance: Las compras en virtud de este Apéndice de las Suscripciones de Software pueden darle derecho a participar en el Programa de Open Source Assurance de Red Hat conforme a un contrato por separado, que se puede consultar (en inglés) en www.redhat.com/legal/open_source_assurance_agreement.html.&lt;/li&gt;
&lt;/ul&gt;
&lt;/blockquote&gt;
&lt;p&gt;Vale, me he registrado para una evaluación y me lo he bajado (o bien lo he conseguido por otros medios, ejem), me lo he instalado, y se han pasado los 30 días de evaluación, ¿ahora qué? Pues en principio podrías seguir usándolo. Y entonces, ¿por qué pagar una suscripción? Pues básicamente porque no tendrás acceso a las actualizaciones (algo muy peligroso), pero allá cada uno, y a mayores no tendrías el soporte que te daría una suscripción.&lt;/p&gt;
&lt;p&gt;¿Y por qué no usar suscripciones de evaluación indefinidamente (siempre en caso de que sólo queramos actualizaciones y no soporte)? Básicamente porque es una chapuza y no puedes. Tras solicitar una suscripción de prueba, no puedes volver a solicitar otra del mismo producto hasta 90 días después, con la misma cuenta. Podrías usar cuentas de correo falsas para crear nuevas cuentas en Red Hat, y prolongar la agonía indefinidamente.... Pero en resumen, chapuzas y ñapas, y aparte puede que te "pillen".&lt;/p&gt;
&lt;p&gt;Y entonces, ¿por qué no usa todo el mundo CentOS, si es igual que Red Hat? Bueno, si eres administrador de sistemas, y estos no son muy críticos, pues puedes pasar. Pero si eres un pinchaiconos, y no te quieres calentar mucho la cabeza, o eres una gran organización, y necesitas que haya una empresa por detrás que te resuelva los problemas o te aconseje en el despliegue de los sistemas, pues deberías plantearte la suscripción. Si bien es cierto que las suscripciones no son baratas para una pequeña o mediana empresa, en ciertos casos pueden salir rentables.&lt;/p&gt;
&lt;p&gt;¿Y cuándo sí que es imprescindible una suscripción? Por ejemplo, si queremos instalar el servidor de base de datos Oracle, éste sólo está soportado oficialmente en Red Hat (y no en CentOS), y además, en muchos casos requieren unas versiones de paquetes que sólo están disponibles en los repositorios de actualizaciones. ¿Y no es posible instalar una versión mayor o menor? Pues sí que es posible, pero Oracle no daría soporte si no se cumplen sus requerimientos. ¿Y si instalo el paquete de actualizado pero de CentOS? Pues eso se ve fácil con un &lt;code&gt;rpm -q&lt;/code&gt;, y se vería que no es la versión compilada para Red Hat, sino la de CentOS. ¿Y no podría compilar yo mismo el SRPM? Podrías, pero volvemos a lo de antes: chapuza, ñapa.&lt;/p&gt;
&lt;p&gt;Y volviendo a este cliente que os comentaba, la razón que alegaba para instalar Red Hat sin suscripciones es "por si algún día tenemos un problema, compramos una suscripción para esa máquina, y listo". Qué queréis que os diga, me reservo la opinión. Así no. Así no se avanza con el software libre. Y "promover" el software libre no es simplemente usarlo, que también. Si no se contribuye, se colabora, se hacen donaciones, etc. al final esto no creo que salga bien. Por ejemplo, en las administraciones públicas, pongamos que sustituyen Microsoft Office (cuyo coste en licencias fuera, por ejemplo, de 600.000 euros) y lo cambian por &lt;a href="https://es.libreoffice.org/"&gt;LibreOffice&lt;/a&gt;. Qué les costaría, ya que se están ahorrando ese dineral, donar, yo qué sé, un 10% a la &lt;a href="http://www.documentfoundation.org/"&gt;Document Foundation&lt;/a&gt;, que se encarga del desarrollo; es algo nimio para la administración, pero un gran aporte para la fundación. Si todas las administraciones públicas hicieran esto, no habría, seguramente, tantas &lt;a href="http://lamiradadelreplicante.com/2014/09/16/el-alcalde-de-munich-advierte-de-debilidades-significativas-en-limux/"&gt;quejas sobre la calidad del software&lt;/a&gt; (no por LibreOffice, sino por muchas otras aplicaciones que, en mi opinión, se incluyen en muchas distribuciones y que no son alternativas válidas para otras aplicaciones ya consolidadas). Por ejemplo, &lt;a href="http://www.linuxmint.com/"&gt;Linux Mint&lt;/a&gt; (para mi la mejor distribución Linux actualmente, en cualquiera de sus entornos), tiene una &lt;a href="http://www.linuxmint.com/donors.php"&gt;lista de donantes&lt;/a&gt; (la mayoría son particulares), y casi todas son donaciones pequeñas. Pero muchas pequeñas donaciones hacen que se avance.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="https://access.redhat.com/articles/1616"&gt;What access and functionality do I lose when the support contract expires for a Red Hat Enterprise Linux product?&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://jehurst.wordpress.com/2011/01/14/rhel-6-and-trial-subscription-keeping-it-alive/"&gt;RHEL 6 and Trial Subscription: Keeping It Alive&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://www.linuxforums.org/forum/red-hat-fedora-linux/139625-why-cant-i-find-free-download-red-hat.html"&gt;Why can't I find a free download of Red Hat?&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary><category term="redhat"></category><category term="licencias"></category></entry><entry><title>Compilar NXLOG en Red Hat/CentOS 5</title><link href="https://okelet.github.io/posts/2014/09/compilar-nxlog-en-red-hatcentos-5/" rel="alternate"></link><updated>2014-09-15T14:24:26+02:00</updated><author><name>Juan Asensio Sánchez</name></author><id>tag:okelet.github.io,2014-09-15:posts/2014/09/compilar-nxlog-en-red-hatcentos-5/</id><summary type="html">&lt;p&gt;&lt;a href="http://nxlog-ce.sourceforge.net"&gt;NXLOG&lt;/a&gt; es un sustituto revitalizado para &lt;a href="http://es.wikipedia.org/wiki/Syslog"&gt;Syslog&lt;/a&gt;. Puede recoger los mensajes tanto desde Windows como de Linux, aplicar reglas, y luego enviarlo a distintos sitios (archivos, bases de datos, servicios web, etc.). El caso es que necesitaba instalar este paquete en un CentOS 5 para enviar los LOGs a un servicio web de indexación, pero no había paquetes precompilados para esta versión.&lt;/p&gt;


&lt;p&gt;Tras leer la documentación, indicaban que lo único que hay que hacer es bajarse el código fuente y ejecutar el comando &lt;code&gt;./make_rpm.sh&lt;/code&gt;. El caso es que esto tampoco funcionaba, pero después de dar 20000 vueltas, y de pura casulalidad, vi que había 2 ficheros &lt;a href="http://www.rpm.org/max-rpm/ch-rpm-inside.html"&gt;SPEC&lt;/a&gt;: uno llamado &lt;code&gt;nxlog.spec&lt;/code&gt; y otro llamado &lt;code&gt;nxlog.spec.RHEL5&lt;/code&gt;. Mirando el código del script &lt;code&gt;make_rpm.sh&lt;/code&gt; he visto que si no se especifica ningún fichero mediante entorno de variable, automáticamente coge el &lt;code&gt;nxlog.spec&lt;/code&gt;, así que lo único que hay que hacer es indicarle mediante una variable de entorno el otro fichero SPEC. Fácil y sencillo (después de darle muchas vueltas)...&lt;/p&gt;
&lt;p&gt;Aquí el &lt;a href="http://es.wikipedia.org/wiki/Cortar,_copiar_y_pegar"&gt;copy-paste&lt;/a&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="nv"&gt;NXLOG_VERSION&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;2.8.1248
yum install rpm-build apr-devel pcre-devel openssl-devel libdbi-devel libcap-devel expat-devel libtool
wget http://sourceforge.net/projects/nxlog-ce/files/nxlog-ce-&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;NXLOG_VERSION&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.tar.gz
tar zxvf nxlog-ce-&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;NXLOG_VERSION&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;.tar.gz
&lt;span class="nb"&gt;cd&lt;/span&gt; nxlog-ce-&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;NXLOG_VERSION&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;/packaging/redhat
&lt;span class="nv"&gt;SPEC_FILE&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;nxlog.spec.RHEL5 ./make_rpm.sh
rpm -Uvh rpmbuild/RPMS/x86_64/nxlog-ce-&lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;NXLOG_VERSION&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;-1.x86_64.rpm
&lt;/pre&gt;&lt;/div&gt;</summary></entry><entry><title>Guía rápida de KVM</title><link href="https://okelet.github.io/posts/2014/08/guia-rapida-de-kvm/" rel="alternate"></link><updated>2014-08-12T13:12:48+02:00</updated><author><name>Juan Asensio Sánchez</name></author><id>tag:okelet.github.io,2014-08-12:posts/2014/08/guia-rapida-de-kvm/</id><summary type="html">&lt;p&gt;De la &lt;a href="http://es.wikipedia.org/wiki/Kernel-based_Virtual_Machine"&gt;Wikipedia&lt;/a&gt;:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Kernel-based Virtual Machine o KVM, (en español, Máquina virtual basada en el núcleo) es una solución para implementar virtualización completa con Linux. Está formada por un módulo del núcleo (con el nombre kvm.ko) y herramientas en el espacio de usuario, siendo en su totalidad software libre. El componente KVM para el núcleo está incluido en Linux desde la versión 2.6.20.&lt;/p&gt;
&lt;p&gt;KVM permite ejecutar máquinas virtuales utilizando imágenes de disco que contienen sistemas operativos sin modificar. Cada máquina virtual tiene su propio hardware virtualizado: una tarjeta de red, discos duros, tarjeta gráfica, etc.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;En primer lugar, debemos comprobar si nuestro equipo es compatible con KVM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;egrep --color &lt;span class="s1"&gt;&amp;#39;(svm|vmx)&amp;#39;&lt;/span&gt; /proc/cpuinfo
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Si la salida anterior muestra algo, podremos seguir adelante. Si no muestra nada, también podremos seguir, pero no se aprovecharán las capacidades de virtualización del equipo (se hará un &lt;a href="http://blog.vmsplice.net/2011/03/should-i-use-qemu-or-kvm.html"&gt;&lt;em&gt;fallback&lt;/em&gt;&lt;/a&gt; a emulación en lugar de virtualización).&lt;/p&gt;


&lt;h2&gt;Instalación en Debian/Ubuntu&lt;/h2&gt;
&lt;p&gt;Para Debian/Ubuntu, deberemos instalar los siguientes paquetes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install cpu-checker qemu-kvm libvirt-bin bridge-utils virt-manager virt-viewer libguestfs-tools
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;También tendremos que añadir nuestro usuario al grupo &lt;code&gt;libvirtd&lt;/code&gt; para poder gestionar máquinas virtuales en el sistema con nuestro propio usuario (sin ser root):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo adduser &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;USER&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt; libvirtd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por último, deberemos reiniciar la sesión para que se recarguen nuestros permisos de usuario.&lt;/p&gt;
&lt;h2&gt;Instalación en Red Hat/CentOS&lt;/h2&gt;
&lt;p&gt;Para Red Hat/CentOS, deberemos instalar los siguientes paquetes:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install kvm libvirt virt-viewer virt-manager virt-sysprep
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para poder gestionar máquinas virtuales sin necesidad de ser root, deberemos crear un grupo, agregar nuestro usuario a ese grupo, y configurar ese grupo en KVM para permitirle la gestión (básicamente, estamos simulando el comportamiento que Ubuntu ya hace por sí solo, &lt;a href="http://n40lab.wordpress.com/2012/10/03/installing-kvm-with-yum-and-compiling-libvirt-and-virtmanager/"&gt;referencia 1&lt;/a&gt; y &lt;a href="http://www.opennet.ru/openforum/vsluhforumID1/93974.html"&gt;referencia 2&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo groupadd libvirtd
sudo usermod -a -G libvirtd &lt;span class="si"&gt;${&lt;/span&gt;&lt;span class="nv"&gt;USER&lt;/span&gt;&lt;span class="si"&gt;}&lt;/span&gt;
sudo sed -r -i -e &lt;span class="s1"&gt;&amp;#39;s/^#?unix_sock_group = .*/unix_sock_group = &amp;quot;libvirtd&amp;quot;/&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
               -e &lt;span class="s1"&gt;&amp;#39;s/^#?unix_sock_rw_perms = .*/unix_sock_rw_perms = &amp;quot;0770&amp;quot;/&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
               -e &lt;span class="s1"&gt;&amp;#39;s/^#?auth_unix_rw = .*/auth_unix_rw = &amp;quot;none&amp;quot;/&amp;#39;&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
               /etc/libvirt/libvirtd.conf
sudo service libvirtd restart
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por último, deberemos reiniciar la sesión para que se recarguen nuestros permisos de usuario.&lt;/p&gt;
&lt;h2&gt;Herramientas principales de gestión&lt;/h2&gt;
&lt;p&gt;Con KVM disponemos de varias herramientas para gestionar tanto el sistema como las propias máquinas virtuales:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;virsh&lt;/code&gt;: nos permite gestionar el sistema y las máquinas virtuales a un nivel medio-bajo.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virt-install&lt;/code&gt;: nos permite crear máquinas virtuales de una forma sencilla.&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Tipos de conexión&lt;/h2&gt;
&lt;p&gt;En la instalación por defecto, tenemos dos tipos de conexión:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;qemu:///system&lt;/code&gt;: nos conectamos al servicio de virtualización del sistema. Las máquinas creadas aquí se pueden configurar para que arranquen automáticamente cuando se inicie el host.&lt;/li&gt;
&lt;li&gt;&lt;code&gt;quemu:///session&lt;/code&gt;: nos conectamos a nuestra propia sesión. Estas máquinas sólo las podrá ver y gestionar el propio usuario, y además, los archivos de imagen (discos duros, etc.), deberán estar en una ubicación donde el usuario pueda leer y escribir (en la ruta por efecto &lt;code&gt;/var/lib/libvirt/images&lt;/code&gt; sólo puede escribir cuando nos conectamos a la URL de sistema).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Según las pruebas que he hecho, los comandos &lt;code&gt;virsh&lt;/code&gt; y &lt;code&gt;virt-instal&lt;/code&gt; (explicados en la siguiente sección) se comportan de manera distinta a la hora de conectarse. &lt;code&gt;virsh&lt;/code&gt; por defecto se conecta a &lt;code&gt;quemu:///system&lt;/code&gt;, mientras que &lt;code&gt;virt-install&lt;/code&gt; se conecta a &lt;code&gt;quemu:///session&lt;/code&gt;. Por esto, en los siguientes ejemplos, se especifica siempre como URL de conexión &lt;code&gt;quemu:///system&lt;/code&gt;, ya que las imágenes de disco se van a crear en &lt;code&gt;/var/lib/libvirt/images&lt;/code&gt;. Si no especificásemos URL de conexión, o pusiéramos la de sesión del usuario, deberíamos establecer una ruta de imagen de disco donde el propio usuario pueda escribir, como &lt;code&gt;${HOME}&lt;/code&gt;.&lt;/p&gt;
&lt;h2&gt;Instalación de virt-manager actualizado&lt;/h2&gt;
&lt;p&gt;Uso Ubuntu 13.10 y la versión en los repositorios es la 0.9.5. La última versión de &lt;code&gt;virt-manager&lt;/code&gt; es la 1.0.1, pero no está en los repositorios para esta versión de Ubuntu (aunque sí a partir de la 14.04); esta última versión tiene bastantes mejoras, entre ellas, la &lt;a href="http://virt-manager.org/download/"&gt;gestión de snapshots&lt;/a&gt;. Para instalar la nueva versión no hay más que descargarse el fuente (está escrita en Python); no hay que compilar ni instalar como root (se pueden tener las 2 versiones de &lt;code&gt;virt-manager&lt;/code&gt;, la de los repositorios y la instalada a mano, pero hay que tener cuidado con cuál ejecutamos para no volverse uno loco).&lt;/p&gt;
&lt;p&gt;En primer lugar, tenemos que descargar una serie de dependencias adicionales que necesitamos (referencias &lt;a href="http://www.gravitycomputing.co.nz/virt-manager-1-01-debian/"&gt;uno&lt;/a&gt; y &lt;a href="http://askubuntu.com/questions/340937/virtmanager-0-95-or-0-10-on-ubuntu-and-cannot-import-name-gtkvnc"&gt;dos&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install gir1.2-spice-client-gtk-3.0 python-gtk-vnc libglib2.0-bin python-ipaddr libvirt-glib-1.0-dev gir1.2-gtk-vnc-2.0
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En principio esto también valdría para Red Hat/CentOS, pero no he encontrado el paquete necesario para la dependencia &lt;code&gt;gi.repository&lt;/code&gt; en CentOS 6, y no he podido hacerlo funcionar.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;yum install python-argparse ...
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Después de instalar las dependencias, nos bajamos el paquete fuente, lo descomprimimos y lo ejecutamos:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;wget http://virt-manager.org/download/sources/virt-manager/virt-manager-1.0.1.tar.gz -O - &lt;span class="p"&gt;|&lt;/span&gt; tar -xz
&lt;span class="nb"&gt;cd&lt;/span&gt; virt-manager-1.0.1
./virt-manager
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Comandos útiles&lt;/h2&gt;
&lt;p&gt;Mostrar la lista de máquinas en ejecución en el sistema:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh -c qemu:///system list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Mostrar todas las máquinas configuradas en el sistema:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh -c qemu:///system list --all
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En los comandos anteriores, podemos sustituir &lt;code&gt;qemu:///system&lt;/code&gt; por &lt;code&gt;quemu:///session&lt;/code&gt; para ver las máquinas asociadas a nuestro usuario (ver apartado anterior).&lt;/p&gt;
&lt;p&gt;Mostrar lista de tipos de sistemas operativos; esto es necesario saberlo para cuando vayamos a instalar una máquina con &lt;code&gt;virt-install&lt;/code&gt;, ya que deberemos especificar el tipo en el momento de la creación:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --os-variant list
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Parar &lt;em&gt;a lo bruto&lt;/em&gt; una máquina:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh destroy nombre_maquina
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Eliminar una máquina y todos sus ficheros asociados (snapshots, ficheros de disco, etc.):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh undefine --managed-save --snapshots-metadata --remove-all-storage nombre_maquina
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Creación rápida de máquinas comunes&lt;/h2&gt;
&lt;p&gt;CentOS 5 32 bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n centos5x32 -r &lt;span class="m"&gt;512&lt;/span&gt; --vcpus&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --os-variant&lt;span class="o"&gt;=&lt;/span&gt;rhel5.4 &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/centos5x32.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://sunsite.rediris.es/mirror/CentOS/5/os/i386 &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;lang=es_ES keyboard=es&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CentOS 5 64 bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n centos5x64 -r &lt;span class="m"&gt;512&lt;/span&gt; --vcpus&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --os-variant&lt;span class="o"&gt;=&lt;/span&gt;rhel5.4 &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/centos5x64.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://sunsite.rediris.es/mirror/CentOS/5/os/x86_64 &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;lang=es_ES keyboard=es&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CentOS 6 32 bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n centos6x32 -r &lt;span class="m"&gt;1024&lt;/span&gt; --vcpus&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --os-variant&lt;span class="o"&gt;=&lt;/span&gt;rhel6 &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/centos6x32.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://sunsite.rediris.es/mirror/CentOS/6/os/i386 &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;lang=es_ES keyboard=es&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CentOS 6 64 bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n centos6x64 -r &lt;span class="m"&gt;1024&lt;/span&gt; --vcpus&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --os-variant&lt;span class="o"&gt;=&lt;/span&gt;rhel6 &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/centos6x64.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://sunsite.rediris.es/mirror/CentOS/6/os/x86_64 &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;lang=es_ES keyboard=es&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;CentOS 7 64 bits (&lt;a href="https://access.redhat.com/solutions/509373"&gt;no existe versión de 32 bits&lt;/a&gt;):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n centos7x64 -r &lt;span class="m"&gt;1024&lt;/span&gt; --vcpus&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;1&lt;/span&gt; --os-variant&lt;span class="o"&gt;=&lt;/span&gt;rhel7 &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/centos7x64.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://sunsite.rediris.es/mirror/CentOS/7/os/x86_64 &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;lang=es_ES keyboard=es&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Debian 7 32 bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n debian7x32 -r &lt;span class="m"&gt;512&lt;/span&gt; --vcpus &lt;span class="m"&gt;1&lt;/span&gt; --os-variant debianwheezy &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/debian7x32.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://ftp.debian.org/debian/dists/wheezy/main/installer-i386/ &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;language=es country=ES debian-installer/locale=es_ES.UTF-8 keyboard-configuration/xkb-keymap=es\&lt;/span&gt;
&lt;span class="s2"&gt;    time/zone=Europe/Madrid passwd/make-user=false&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Debian 7 64 bits:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-install --connect qemu:///system -n debian7x64 -r &lt;span class="m"&gt;512&lt;/span&gt; --vcpus &lt;span class="m"&gt;1&lt;/span&gt; --os-variant debianwheezy &lt;span class="se"&gt;\&lt;/span&gt;
--graphics spice --disk &lt;span class="nv"&gt;path&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;/var/lib/libvirt/images/debian7x64.qcow2,format&lt;span class="o"&gt;=&lt;/span&gt;qcow2,size&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="m"&gt;8&lt;/span&gt; &lt;span class="se"&gt;\&lt;/span&gt;
-l http://ftp.debian.org/debian/dists/wheezy/main/installer-amd64/ &lt;span class="se"&gt;\&lt;/span&gt;
-x &lt;span class="s2"&gt;&amp;quot;language=es country=ES debian-installer/locale=es_ES.UTF-8 keyboard-configuration/xkb-keymap=es \&lt;/span&gt;
&lt;span class="s2"&gt;    time/zone=Europe/Madrid passwd/make-user=false&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Los comandos anteriores tienen el parámetro &lt;code&gt;-x&lt;/code&gt; (&lt;code&gt;--extra-args&lt;/code&gt;). Estos parámetros se pasan automáticamente al kernel de arranque de instalación del sistema operativo. Con ellos, podemos configurar automáticamente ciertos parámetros que se nos pide durante la instalación (los más usados en los ejemplos anteriores sirven para configurar el idioma, la localización, la distribución del teclado, la zona horaria, o incluso si crear o no un usuario regular en el sistema). También es posible pasar una ruta a un fichero KickStart (Red Hat/CentOS) o Preseed (Debian/Ubuntu) para automatizar completamente la instalación. Más información:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Red Hat/CentOS: parámetros de arranque &lt;a href="https://www.centos.org/docs/5/html/Installation_Guide-en-US/ch-bootopts-x86.html"&gt;uno&lt;/a&gt; y &lt;a href="https://www.centos.org/docs/5/html/installation_Guide-en-US/s1-kickstart2-options.html"&gt;dos&lt;/a&gt;, &lt;a href="http://fedoraproject.org/wiki/Anaconda/Kickstart"&gt;Kickstart&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Debian/Ubuntu: &lt;a href="https://www.debian.org/releases/stable/i386/ch05s03.html.en"&gt;parámetros de arranque&lt;/a&gt;, &lt;a href="https://wiki.debian.org/DebianInstaller/"&gt;Preseed&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para especificar un proxy de instalación en los casos anteriores, se deben especificar las siguientes opciones:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Para Debian/Ubuntu: &lt;code&gt;mirror/http/proxy=http://[usuario:contraseña@]proxy.dominio.com:3128/&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Para CentOS/Red Hat: &lt;code&gt;proxy=http://[usuario:contraseña@]proxy.dominio.com:3128/&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;La opción &lt;code&gt;--graphics spice&lt;/code&gt; especificada en los comandos anteriores permite una mejor calidad y mayor rendimiento de los gráficos en la máquina virtual, usando el driver &lt;code&gt;qxl&lt;/code&gt;, así  como una mejor integración con el host a través del protocolo &lt;a href="spice-space.org"&gt;Spice&lt;/a&gt;, permitiendo el cambio de resolución de la máquina virtual según redimensionemos el visor, redirección del sonido, copiar y pegar, etc. En caso de que no se especifique esta opción se usaría una comunicación mediante VNC y un driver Cirrus. Para que el protocolo Spice funcion correctamente en la máquina virtual, deberemos asegurarnos que está instalado el driver gráfico adecuado y el agente de Spice, según lo indicado en el siguiente apartado.&lt;/p&gt;
&lt;h2&gt;Cambiar Cirrus/VNC por QXL/Spice&lt;/h2&gt;
&lt;p&gt;Como he comentando antes, el protocolo Spice ofrece un rendimiento mayor y mejor integración con el huésped. Si tenemos alguna máquina virtual creada con las opciones por defecto, podemos actualizarla cambiando las opciones adecuadas. Para ello, con la máquina virtual parada, editaremos su configuración XML y mofificaremos los bloques especificados a continuación:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh edit nombre_maquina
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;channel&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;spicevmc&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;target&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;virtio&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;com.redhat.spice.0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;address&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;virtio-serial&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;controller=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;bus=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;port=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/channel&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;graphics&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;spice&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;autoport=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;yes&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;video&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;model&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;qxl&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;ram=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;65536&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;vram=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;65536&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;heads=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;1&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;address&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pci&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;domain=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x0000&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;bus=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x00&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;slot=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x02&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;function=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/video&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tras esto, ya podemos arrancar la máquina virtual y debemos asegurarnos de tener instalado tanto el driver gráfico correspondiente, como el agente de Spice. Para ello, ejecutaremos los siguientes comandos en distribuciones Debian/Ubuntu:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install xserver-xorg-video-qxl spice-vdagent
sudo update-rc.d spice-vdagent defaults
sudo service spice-vdagent start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Estos otros en distribuciones Red Hat/CentOS con SysV (versiones 6 y anteriores):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install xorg-x11-drv-qxl spice-vdagent
sudo chkconfig spice-vdagentd on
sudo service spice-vdagentd start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Y estos otros en distribuciones Red Hat/CentOS con Systemd (versiones 7 y posteriores):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo yum install xorg-x11-drv-qxl spice-vdagent
sudo systemctl &lt;span class="nb"&gt;enable&lt;/span&gt; spice-vdagentd
sudo systemctl start spice-vdagentd
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para finalizar, deberemos reiniciar la máquina virtual para que se apliquen los cambios.&lt;/p&gt;
&lt;h2&gt;Intercambiar entre KVM y VirtualBox&lt;/h2&gt;
&lt;p&gt;Si se tiene instalado VirtualBox, KVM no se ejecutará con todas las características de virtualización completas, sino que delegará en QEMU (que es mucho más lento), o bien VirtualBox no se ejecutará diciendo que no se han podido cargar sus módulos (&lt;a href="http://www.dedoimedo.com/computers/kvm-virtualbox.html"&gt;dependiendo del orden de carga de los módulos de KVM o VirtualBox, será uno u otro el que no funcione&lt;/a&gt;). Para solventar esto, o bien debemos desinstalar uno de los dos sistemas, o bien debemos desactivar los módulos del otro cuando vayamos a ejecutar un sistema de virtualización.&lt;/p&gt;
&lt;p&gt;Para usar KVM:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo /etc/init.d/vboxdrv stop
sudo modprobe kvm
sudo modprobe kvm_intel
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Para usar VirtualBox:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo modprobe -r kvm_intel
sudo modprobe -r kvm
sudo /etc/init.d/vboxdrv start
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;En mi caso, que tengo en el trabajo un Dell OptiPlex 755, hay que tocar algunas cosas en la BIOS para que funcione correctamente KVM, ya que cuando intentaba cargar el módulo &lt;code&gt;kvm_intel&lt;/code&gt; me daba un error de &lt;code&gt;Operation not supported&lt;/code&gt;. En esta &lt;a href="http://serverfault.com/questions/534934/vt-enabled-in-bios-but-kvm-failed-to-detect"&gt;pregunta de serverfault&lt;/a&gt;, que a su vez &lt;a href="http://reidablog.blogspot.com.es/2008/06/with-correct-bios-settings-enabled-on.html"&gt;hace referencia a ésta&lt;/a&gt;, indican las opciones de la BIOS que se deben poner para que funcione; en resumen:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Security: Execute Disable should be On&lt;/li&gt;
&lt;li&gt;Performance: Virtualization should be On&lt;/li&gt;
&lt;li&gt;Performance: VT for Direct I/O Access should be On&lt;/li&gt;
&lt;li&gt;Performance: Trusted Execution should be Off&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Snapshots&lt;/h2&gt;
&lt;p&gt;Para poder tomar snapshots, el formato de los discos debe ser alguno que sea compatible; si al crear la máquina, no se especifica uno, se crearán con el formato &lt;code&gt;raw&lt;/code&gt;, que no los permite; por eso, en todos los comandos anteriores se usa el formato &lt;code&gt;qcow2&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;Mostrar los snapshots de una máquina:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh snapshot-list nombre_maquina
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tomar un snapshot de una máquina:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh snapshot-create-as nombre_maquina &lt;span class="s2"&gt;&amp;quot;Nombre del snapshot (opcional)&amp;quot;&lt;/span&gt; &lt;span class="s2"&gt;&amp;quot;Descripción del snapshot (opcional)&amp;quot;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Revertir a un snapshot anterior:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh snapshot-revert nombre_maquina &lt;span class="o"&gt;[&lt;/span&gt;nombre_snapshot&lt;span class="p"&gt;|&lt;/span&gt;--current&lt;span class="o"&gt;]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Eliminar un snapshot:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh snapshot-delete nombre_maquina &lt;span class="o"&gt;[&lt;/span&gt;nombre_snapshot&lt;span class="p"&gt;|&lt;/span&gt;--current&lt;span class="o"&gt;]&lt;/span&gt; &lt;span class="o"&gt;[{&lt;/span&gt;--children &lt;span class="p"&gt;|&lt;/span&gt; --children-only&lt;span class="o"&gt;}]&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Convertir imágenes de disco a QCOW2&lt;/h2&gt;
&lt;p&gt;En caso de que tengamos una máquina virtual con un disco en formato &lt;code&gt;raw&lt;/code&gt;, no podremos utilizar la funcionalidad de snapshots, como hemos comentado antes. Para solucionar esto, deberemos convertir el fichero de imagen de la máquina a formato &lt;code&gt;qcow2&lt;/code&gt;, y luego editar la configuración de la máquina virtual para decirle que hemos cambiado el formato del disco.&lt;/p&gt;
&lt;p&gt;Para convertir el formato (se debe hacer con la máquina apagada, y con &lt;code&gt;sudo&lt;/code&gt; ya que necesita acceder directamente al disco para leerlo y luego poder crear el nuevo):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo qemu-img convert -f raw -O qcow2 /var/lib/libvirt/images/centos7x64.&lt;span class="o"&gt;{&lt;/span&gt;img,qcow2&lt;span class="o"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tras esto, debemos reconfigurar la máquina virtual para indicar el nuevo nombre del fichero y formato del disco (al igual que antes, con la máquina apagada):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virsh edit centos7x64
&lt;/pre&gt;&lt;/div&gt;


&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;    &lt;span class="nt"&gt;&amp;lt;disk&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;file&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;device=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;disk&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;driver&lt;/span&gt; &lt;span class="na"&gt;name=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;qemu&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;qcow2&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;source&lt;/span&gt; &lt;span class="na"&gt;file=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;/var/lib/libvirt/images/centos7x64.qcow2&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;target&lt;/span&gt; &lt;span class="na"&gt;dev=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;vda&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;bus=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;virtio&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
      &lt;span class="nt"&gt;&amp;lt;address&lt;/span&gt; &lt;span class="na"&gt;type=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;pci&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;domain=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x0000&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;bus=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x00&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;slot=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x04&amp;#39;&lt;/span&gt; &lt;span class="na"&gt;function=&lt;/span&gt;&lt;span class="s"&gt;&amp;#39;0x0&amp;#39;&lt;/span&gt;&lt;span class="nt"&gt;/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/disk&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h2&gt;Clonar máquinas virtuales&lt;/h2&gt;
&lt;p&gt;A la hora de clonar máquinas virtuales debemos tener en cuenta varias cosas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se debe duplicar el disco&lt;/li&gt;
&lt;li&gt;Se debe generar una nueva dirección MAC para cada una de las tarjetas de red&lt;/li&gt;
&lt;li&gt;A nivel de sistema operativo:&lt;ul&gt;
&lt;li&gt;Cambiar la dirección MAC con la nueva en los archivos de configuración (&lt;code&gt;/etc/sysconfig/network-scripts/ifcfg-eth*&lt;/code&gt; en Red Hat/CentOS)&lt;/li&gt;
&lt;li&gt;Se deben eliminar y regerenerar las claves SSH antiguas&lt;/li&gt;
&lt;li&gt;Se deberían eliminar los usuarios del sistema original&lt;/li&gt;
&lt;/ul&gt;
&lt;/li&gt;
&lt;li&gt;Y cualquier cosa más que se nos ocurra&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para realizar todas estas tareas, disponemos principalmente de 2 herramientas:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;code&gt;virt-clone&lt;/code&gt;: realiza el clonado en sí de la máquina, copiando el disco, y cambiando las direcciones MAC de las tarjetas (a nivel de KVM sólo, no a nivel del sistema operativo virtual).&lt;/li&gt;
&lt;li&gt;&lt;code&gt;virt-sysprep&lt;/code&gt;: permite realizar modificaciones en el sistema operativo para configurarlo correctamente con las nuevas especificaciones (MAC, SSH, etc.).&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Desde la aplicación &lt;code&gt;virt-manager&lt;/code&gt; es bastante sencillo, pues se realiza en apenas 2 clicks por la interfaz gráfica. Para hacerlo por comandos, realizaremos los siguientes pasos. En primer lugar, clonaremos la máquina en sí (si no especificamos manualmente un disco de destino con la opción &lt;code&gt;--file&lt;/code&gt;, se nos creará uno automáticamente con el nombre de a nueva máquina; si no especificamos tampoco una MAC manualmente con el parámetro &lt;code&gt;--mac&lt;/code&gt;, se generará una aleatoria automáticamente):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;virt-clone --connect qemu:///system --original centos6x32 --auto-clone --name centos6x32-clone 
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Tras esto, ejecuataremos (&lt;code&gt;virt-sysprep&lt;/code&gt; se tiene que ejecutar con &lt;code&gt;sudo&lt;/code&gt; o dar permisos de lectura y escritura al usuario actual sobre el archivo de imagen de la máquina virtual, ya que tiene que realizar modificaciones directamente sobre él):&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo virt-sysprep --connect qemu:///system --domain centos6x32-clone
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;El comando anterior lanzará una serie de modificaciónes &lt;em&gt;estándar&lt;/em&gt;; estas modificaciones se pueden personalizar con los parámetros &lt;code&gt;--enable&lt;/code&gt; y &lt;code&gt;--operations&lt;/code&gt;; es posible ver la lista de operaciones posibles con el parámetro &lt;code&gt;--list-operations&lt;/code&gt;, y ver lo que se haría sobre la máquina sin realmente hacerlo con el parámetro &lt;code&gt;--dry-run&lt;/code&gt;.&lt;/p&gt;
&lt;p&gt;NOTA: La versión de Ubuntu que utilizo es la 13.10, que tiene una versión bastante antigua del comando &lt;code&gt;virt-sysprep&lt;/code&gt;, y no reconoce varias de las opciones anteriores, y tiene &lt;a href="https://bugzilla.redhat.com/show_bug.cgi?id=1111662"&gt;este bug&lt;/a&gt;; para solventarlo, lo que hago es pasarle manualmente la lista de operaciones a realizar:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo virt-sysprep --connect qemu:///system -d centos6x32-clone --enable bash-history,logfiles,hostname,machine-id,net-hwaddr,ssh-hostkeys,ssh-userdir
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Hay una herramienta adicional (&lt;code&gt;virt-customize&lt;/code&gt;) que permite realizar modificaciones sobre el sistema operativo (al estilo de &lt;a href="http://www.ansible.com/home"&gt;Ansible&lt;/a&gt;, &lt;a href="http://puppetlabs.com/"&gt;Puppet&lt;/a&gt;, &lt;a href="http://www.saltstack.com/"&gt;Salt&lt;/a&gt;, &lt;a href="http://www.getchef.com/chef/"&gt;Chef&lt;/a&gt;, etc. pero más básico), pudiendo establecer la contraseña de root y de usuarios, instalar paquetes, actualizar el sistema, establecer el nombre de host, etc. Lamentablemente, esta aplicación sólo está disponible a partir de la versión 1.26 de &lt;a href="http://libguestfs.org/"&gt;libguestfs&lt;/a&gt;, que es bastante posterior a la que hay en Ubuntu. Simplemente, a modo de referencia, el comando funcionaría de la siguiente forma:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo virt-customize --connect qemu:///system -d centos6x32-clone --hostname nuevonombre.pruebas.test
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Referencias:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://libguestfs.org/virt-customize.1.html"&gt;man virt-customize&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="http://libguestfs.org/virt-sysprep.1.html"&gt;man virt-sysprep&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href="https://rwmj.wordpress.com/tag/virt-sysprep/"&gt;Richard WM Jones: virt-sysprep&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry><entry><title>Red NAT privada con salida al exterior en VirtualBox</title><link href="https://okelet.github.io/posts/2014/08/red-nat-privada-con-salida-al-exterior-en-virtualbox/" rel="alternate"></link><updated>2014-08-07T13:49:59+02:00</updated><author><name>Juan Asensio Sánchez</name></author><id>tag:okelet.github.io,2014-08-07:posts/2014/08/red-nat-privada-con-salida-al-exterior-en-virtualbox/</id><summary type="html">&lt;p&gt;Una de las cosas que más echo en falta en &lt;a href="https://www.virtualbox.org"&gt;VirtualBox&lt;/a&gt; con respecto a cuando trabajaba con &lt;a href="http://www.vmware.com/es/products/workstation"&gt;VMware Workstation&lt;/a&gt; o &lt;a href="http://www.vmware.com/es/products/player"&gt;Player&lt;/a&gt;, al trabajar una máquina local para hacer pruebas, es que estas últimas te creaban varios tipos de redes por defecto que VirtualBox no hace. La más útil para mi, sobre todo cuando estás en un cliente en el que es difícil solicitar IPs o cuando quieres crear una red interna de pruebas, es crear una &lt;a href="https://www.vmware.com/support/ws3/doc/ws32_network21.html"&gt;red privada de la que formen parte tanto las máquinas virtuales como la propia máquina anfitriona, y que tenga salida al exterior mediante NAT&lt;/a&gt;. &lt;/p&gt;


&lt;p&gt;En las últimas versiones de VirtualBox (a partir de la 4.3, en modo experimental) existe el llamado &lt;a href="https://www.virtualbox.org/manual/ch06.html#network_nat_service"&gt;NAT Service&lt;/a&gt;, que simula el comportamiento anterior de VMware, pero que no permite la conexión desde la máquina anfitriona (ya que, al contrario que VMware, VirtualBox no crea una interfaz virtual para esta red) hacia las máquinas virtuales o a la inversa. Esto es muy cómodo cuando quieres hacer SSH hacia las máquinas virtuales, ya que no tienes que estar redirigiendo puertos, que es la única forma de hacerlo con VirtualBox en el modo NAT Service (y no digamos si tienes varias máquinas virtuales, el lío de redirección de puertos y parámetros al SSH para conectar a las diferentes máquinas virtuales).&lt;/p&gt;
&lt;p&gt;Buscando una solución alternativa y lo más transparente y sencilla de gestionar, hace tiempo descubrí &lt;a href="http://www.tolaris.com/2012/05/16/using-host-networking-and-nat-with-virtualbox-v2-0"&gt;esta página&lt;/a&gt; que lo que hace es crear una interfaz virtual en la máquina anfitrión, configurando el reenvío TCP y un servidor &lt;a href="http://www.thekelleys.org.uk/dnsmasq/doc.html"&gt;Dnsmasq&lt;/a&gt; para servir direcciones por DHCP y la resolución DNS de esa red. De esta forma, si la red de las máquinas virtuales se configura en modo bridge, usando la interfaz creada, todas podrán comunicarse entre sí y con la máquina anfitrión, aparte de tener un servidor DHCP y DNS (por lo que podremos crear asignaciones de direcciones estáticas, entradas DNS para un dominio ficticio interno, etc.). Además, las máquinas virtuales tendrán salida al exterior, ya que la máquina anfitrión realizará NAT del tráfico saliente que se reciba desde esta red. Incluso podemos montar un servidor PXE para arrancar sistemas en red o la instalación automática mediante &lt;a href="http://fedoraproject.org/wiki/Anaconda/Kickstart"&gt;Kickstart&lt;/a&gt;, &lt;a href="http://www.cobblerd.org"&gt;Clobber&lt;/a&gt; o &lt;a href="https://wiki.debian.org/DebianInstaller/Preseed"&gt;Preseed&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Para rizar aún más el rizo, decidí simplificar la configuración. La anterior está bien, pero es necesario tener bastantes cosas en cuenta (la interfaz, el paquete bridge-utils, el reenvío TCP, la configuración de Dnsmasq, etc.), y se complica a mayores cuando quieres tener varias redes virtuales separadas y que se comuniquen entre sí. Buscando un poco más, descubrí &lt;a href="http://ballardini.com.ar/blog/red-portatil-v-interfaz-tap-en-anfitrion-y-en-huesped-kvm"&gt;esta página&lt;/a&gt; en la que se combinan todos los pasos anteriores en un único punto. En resumen, lo que se hace es crear una interfaz virtual, y en los precomandos y postcomandos al levantar y apagar la interfaz, se ejecutan todos los pasos necesarios. Para poner en marcha esto, lo primero será instalar Dnsmasq y los paquetes necesarios para crear la interfaz virtual:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;apt-get install dnsmasq vde2 bridge-utils
update-rc.d dnsmasq disable
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;[su_box title="Nota"]
Es necesario deshabilitar &lt;code&gt;dnsmasq&lt;/code&gt; del arranque ya que la configuración por defecto escucha por todas las interfaces, y al levantar &lt;code&gt;dnsmasq&lt;/code&gt; por cada interfaz virtual, da un error diciendo que la dirección ya está en uso.
[/su_box]&lt;/p&gt;
&lt;p&gt;Para no tener que tocar mucho el archivo /etc/network/interfaces, y poder gestionar más fácilmente las interfaces virtuales que creemos, configuraremos el sistema para que &lt;a href="http://askubuntu.com/questions/323566/separate-etc-network-interfaces-file"&gt;cargue dinámicamente todos los archivos de configuración desde el directorio /etc/network/interfaces.d&lt;/a&gt;; para ello, tendremos que añadir, si no existe ya, esta línea:&lt;/p&gt;
&lt;p&gt;{% codeblock /etc/network/interfaces lang:text %}
auto lo
iface lo inet loopback&lt;/p&gt;
&lt;p _="%" endcodeblock="endcodeblock"&gt;source /etc/network/interfaces.d/*.cfg&lt;/p&gt;
&lt;p&gt;Y por supuesto, crear dicho directorio:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;mkdir -p /etc/network/interfaces.d
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;A continuación, ya podemos definir la interfaz:&lt;/p&gt;
&lt;p&gt;{% codeblock /etc/network/interfaces.d/vnet0.cfg lang:text %}
auto vnet0
iface vnet0 inet static&lt;/p&gt;
&lt;p&gt;address 192.168.77.253
  netmask 255.255.255.0&lt;/p&gt;
&lt;p&gt;############################################################################################################
  # Arranque de la interfaz
  ############################################################################################################&lt;/p&gt;
&lt;p&gt;# Crear la interfaz virtual
  pre-up /usr/bin/vde_switch --tap ${IFACE} --daemon --group vde2-net --sock /var/run/${IFACE}.ctl \
   --mod 775 --mgmtmode 770 --mgmt /var/run/${IFACE}-manage --pidfile /var/run/${IFACE}_vde.pid&lt;/p&gt;
&lt;p&gt;# Comprobamos si existe un archivo de configuración de Dnsmasq, y si no existe, creamos uno vacío
  # para que no se queje el proceso de Dnsmasq al levantarlo
  up test -e /etc/dnsmasq_${IFACE}.conf || touch /etc/dnsmasq_${IFACE}.conf&lt;/p&gt;
&lt;p&gt;# Levantar el proceso de Dnsmasq, pasando como interfaz a la que asociarse la propia interfaz y el
  # rango DHCP para asignar direcciones (la dirección de la interfaz definida arriba debe estar en este
  # rango); se pueden especificar más parámetros añadiéndolos aquí o creando/modificando un archivo
  # de configuración según la instrucción anterior.
  up /usr/sbin/dnsmasq --interface=${IFACE} --except-interface=lo --bind-interfaces --user=nobody \
     --dhcp-range=${IFACE},192.168.77.101,192.168.77.199,8h \
     --local=/pruebas.intra/ --domain=pruebas.intra \
     --pid-file=/var/run/${IFACE}&lt;em&gt;dnsmasq.pid --conf-file=/etc/dnsmasq&lt;/em&gt;${IFACE}.conf&lt;/p&gt;
&lt;p&gt;# Añadir una regla a iptables para natear el tráfico saliente de esta red
  post-up iptables -t nat -I POSTROUTING -s 192.168.77.0/24 -j MASQUERADE&lt;/p&gt;
&lt;p&gt;############################################################################################################
  # Parada de la interfaz
  ############################################################################################################&lt;/p&gt;
&lt;p&gt;# Eliminar el nateo del tráfico saliente asociada a la red
  pre-down iptables -t nat -D POSTROUTING -s 192.168.77.0/24 -j MASQUERADE&lt;/p&gt;
&lt;p&gt;# Parar el proceso de Dnsmasq
  down kill $(cat /var/run/${IFACE}_dnsmasq.pid) &amp;amp;&amp;amp; rm -f /var/run/${IFACE}_dnsmasq.pid&lt;/p&gt;
&lt;p&gt;# Borrar el archivo de configuración de Dnsmasq si está vacío (para mantener limpio el sistema)
  down test -s /etc/dnsmasq_${IFACE}.conf || rm -f /etc/dnsmasq_${IFACE}.conf&lt;/p&gt;
&lt;p _="%" endcodeblock="endcodeblock"&gt;# Eliminar la interfaz virtual
  post-down kill $(cat /var/run/${IFACE}_vde.pid) || kill -9 $(cat /var/run/${IFACE}_vde.pid)&lt;/p&gt;
&lt;p&gt;[su_box title="Nota"]
En el post original de donde saqué esta configuración (el segundo referenciado), la regla de &lt;span class="lang:default highlight:0 decode:true crayon-inline "&gt;iptables&lt;/span&gt; hacía referencia a la interfaz de salida, y no a la red de origen como he puesto yo. Esto lo he tenido que hacer ya que Ubuntu usa NetworkManager, y parece que levanta esta interfaz antes que las demás (por ejemplo, con la que tengamos configurada como principal como &lt;span class="lang:default highlight:0 decode:true crayon-inline "&gt;eth0&lt;/span&gt; o &lt;span class="lang:default highlight:0 decode:true crayon-inline "&gt;wlan0&lt;/span&gt;), por lo que no es posible la interfaz de salida de la ruta por defecto (y que además esta interfaz puede cambiarse desde el escritorio). Por tanto, lo que he hecho, es que en la regla de &lt;span class="lang:default highlight:0 decode:true crayon-inline "&gt;iptables&lt;/span&gt;, en lugar de hacer NAT a todo lo que salga por la interfaz por defecto tras el enrutado, es hacer NAT a todo lo que venga de la red de la interfaz virtual tras el enrutado.&lt;/p&gt;
&lt;p&gt;Esto tiene un problema, que no creo que sea difícil de solucionar, pero que no lo he hecho, y es que si hay varias interfaces virtuales y queremos comunicar máquinas de distintas redes, siempre se hará NAT, aunque no salgan del propio host anfitrión.
[/su_box]&lt;/p&gt;
&lt;p&gt;El único paso que he dejado fuera es la configuración del reenvío TCP, ya que no está ligado a una interfaz en concreto, sino que va a nivel de sistema.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;net.ipv4.ip_forward=1
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Recargamos la configuración para que se aplique el cambio anterior:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sysctl -p
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Las ventajas de esta configuración sobre la primera es que:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Se levanta un proceso Dnsmasq distinto para cada interfaz, con un archivo de configuración específico, por lo que se pueden agregar en el fichero datos que no se pasan directamente al programa por parámetros, como asignaciones de IPs estáticas, registros DNS, etc.&lt;/li&gt;
&lt;li&gt;Se pueden tener varias interfaces virtuales, cada una con su propia configuración DNS, simplemente creando una nueva interfaz copiando y pegando tantas veces el bloque anterior y modificando los datos mínimos (sobre todo la dirección IP, el rango DHCP y las reglas de iptables), o creando un archivo distinto por cada interfaz en el directorio &lt;code&gt;/etc/network/interfaces.d&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;Para finalizar, se puede modificar la configuración de Dnsmasq para personalizar las asignaciones DHCP, la resolución DNS, así como hacer que los sistemas arranquen desde la red con PXE; hay configuraciones de ejemplo en esta página.&lt;/p&gt;</summary></entry><entry><title>Instalar, configurar y securizar MariaDB</title><link href="https://okelet.github.io/posts/2014/08/instalar-configurar-y-securizar-mariadb/" rel="alternate"></link><updated>2014-08-07T13:49:42+02:00</updated><author><name>Juan Asensio Sánchez</name></author><id>tag:okelet.github.io,2014-08-07:posts/2014/08/instalar-configurar-y-securizar-mariadb/</id><summary type="html">&lt;p&gt;La página de &lt;a href="http://www.ibm.com/developerworks"&gt;IBM developerWorks&lt;/a&gt; no para de sorprenderme. Muchas de las veces que busco documentación técnica, cursos, tutoriales, etc. allí están ellos, y con un material gratuito y de muy alta calidad. La última, fue con la instalación de este blog. Tengo un VPS contratado con Ubuntu, que he ido actualizando poco a poco, y que lo tengo bastante pelado. Me decidí por instalar en él WordPress (tras mucho analizar otros sistemas para publicar artículos tipo &lt;a href="http://dokuwiki.org"&gt;Dokuwiki&lt;/a&gt;, &lt;a href="http://octopress.org"&gt;Octopress&lt;/a&gt;, &lt;a href="http://jekyllrb.com"&gt;Jekyll&lt;/a&gt;, &lt;a href="http://getpelican.com"&gt;Pelican&lt;/a&gt;, etc.). Lo primero que me sorprendió es que no soporta &lt;a href="http://www.postgresql.org"&gt;PostgreSQL&lt;/a&gt; de forma oficial (que sería mi primera opción), por mis &lt;a href="http://techcrunch.com/2012/08/18/oracle-makes-more-moves-to-kill-open-source-mysql"&gt;reticencias con MySQL&lt;/a&gt;, pero más tarde de acordé del fork que se creó hace un tiempo, llamado &lt;a href="http://mariadb.org"&gt;MariaDB&lt;/a&gt;. Leyendo un poco, parece ser que MariaDB es "binariamente" (si es que eso existe en castellano) &lt;a href="https://mariadb.com/kb/en/mariadb/mariadb-vs-mysql-compatibility"&gt;compatible con MySQL&lt;/a&gt; (es decir, que el protocolo de comunicación, los ficheros de base de datos, etc. son totalmente compatibles, si no iguales).&lt;/p&gt;


&lt;p&gt;Bueno, a lo que iba. Ya que con PostgreSQL no se puede (o por lo menos, no está oficialmente soportado), opté por instalar MariaDB. Desde su web tienen un &lt;a href="https://downloads.mariadb.org/mariadb/repositories"&gt;asistente muy sencillo&lt;/a&gt; para configurar los repositorios de las distribuciones Linux más comunes (openSUSE, Debian, Ubuntu, Red Hat, CentOS, etc.). Tienen paquetes precompilados para prácticamente todas las versiones y arquitecturas (la única que echo en falta es Red Hat 7, aunque se lo perdono porque acaba de salir hace nada...).&lt;/p&gt;
&lt;p&gt;Una vez configurados los repositorios, toca la parte de la instalación; sencillísima como siempre:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get update
sudo apt-get install mariadb-server php5-mysql
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Lo que más miedo me da de estas instalaciones tan "sencillísimas" es que muchas veces dejan el servidor o el servicio instalado bastante desprotegido. Durante la instalación, se nos pregunta que si queremos ponerle una contraseña al usuario root de MariaDB/MySQL.... Pero qué cosas, nos permite dejarlo en blanco. MAL MAL MAL. Como decía, gracias a los tutoriales de developerWorks, descubrí que hay un comando muy sencillo que te "quita" todas esas inseguridades; a saber:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Ponerle una contraseña al usuario root de MariaDB/MySQL en condiciones.&lt;/li&gt;
&lt;li&gt;Eliminar el usuario anonymous&lt;/li&gt;
&lt;li&gt;Deshabilitar el acceso remoto de root&lt;/li&gt;
&lt;li&gt;Eliminar la base de datos test&lt;/li&gt;
&lt;li&gt;Recargar los privilegios&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;El comando mágico es &lt;code&gt;mysql_secure_installation&lt;/code&gt;, aunque parece que no está muy afinado, ya que nada más lanzarlo da un error:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;/usr/bin/mysql_secure_installation: 379: /usr/bin/mysql_secure_installation: find_mysql_client: not found
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;También da un error al intentar borrar la base de datos test:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;Remove test database and access to it? [Y/n] 
 - Dropping test database...
ERROR 1008 (HY000) at line 1: Can&amp;#39;t drop database &amp;#39;test&amp;#39;; database doesn&amp;#39;t exist
 ... Failed!  Not critical, keep moving...
 - Removing privileges on test database...
 ... Success!
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Puedes ver la salida completa del comando en este &lt;a href="https://gist.github.com/okelet/b416b13f85831afb98fe"&gt;Gist&lt;/a&gt;.&lt;/p&gt;
&lt;p&gt;Una vez hecho esto, ya podemos decir que nuestra instalación está bastante adecentada. Lo que nos quedaría, si usamos un cortafuegos (que deberíamos), sería limitar el acceso. Si la regla por defecto es denegar las conexiones entrantes, no deberíamos tener problema; si no, deberíamos añadir una regla para denegar las conexiones remotas entrantes al puerto 3306.  El siguiente listado muestra los comandos necesarios para configurar el cortafuegos de manera rápida con &lt;a href="https://help.ubuntu.com/community/UFW"&gt;UFW&lt;/a&gt;, permitiendo el acceso desde fuera por SSH, HTTP y HTTPS, denegando todo el resto de tráfico entrante, y permitiendo por defecto el tráfico saliente:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;sudo apt-get install ufw
sudo ufw &lt;span class="nb"&gt;enable&lt;/span&gt;
sudo ufw default deny incoming
sudo ufw default allow outgoing
sudo ufw allow ssh/tcp
sudo ufw allow http/tcp
sudo ufw allow https/tcp
sudo ufw status
&lt;/pre&gt;&lt;/div&gt;


&lt;p&gt;Por último, y como algo particular para WordPress, crearemos una base de datos, un usuario y le daremos permisos al usuario sobre esa base de datos, para lo que ejecutaremos el comando &lt;code&gt;mysql -uroot -p&lt;/code&gt;, introduciendo después la contraseña asignada antes al usuario root, y ejecutando los siguientes comandos desde el shell de MariaDB:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span&gt;&lt;/span&gt;&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;DATABASE&lt;/span&gt; &lt;span class="n"&gt;wordpress&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;CREATE&lt;/span&gt; &lt;span class="k"&gt;USER&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;wpuser&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt; &lt;span class="n"&gt;IDENTIFIED&lt;/span&gt; &lt;span class="k"&gt;BY&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;pickApassword&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;GRANT&lt;/span&gt; &lt;span class="k"&gt;ALL&lt;/span&gt; &lt;span class="k"&gt;PRIVILEGES&lt;/span&gt; &lt;span class="k"&gt;ON&lt;/span&gt; &lt;span class="n"&gt;wordpress&lt;/span&gt; &lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="k"&gt;TO&lt;/span&gt; &lt;span class="s1"&gt;&amp;#39;wpuser&amp;#39;&lt;/span&gt;&lt;span class="o"&gt;@&lt;/span&gt;&lt;span class="s1"&gt;&amp;#39;localhost&amp;#39;&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;FLUSH&lt;/span&gt; &lt;span class="k"&gt;PRIVILEGES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;exit&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;


&lt;h3&gt;Referencias&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://www.ibm.com/developerworks/cloud/library/cl-softlayer-secure-wordpressblog-trs"&gt;IBM developerWorks: Create a secure WordPress blog using SoftLayer&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;</summary></entry></feed>